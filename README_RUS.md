# Parallels

Реализация проекта Parallels.


## Contents

1. [Chapter I](#chapter-i) \
   1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
   2.1. [Многопоточность](#многопоточность) \
   2.2. [Мьютексы](#мьютексы) \
   2.3. [Метод конвейерного параллелизма](#метод-конвейерного-параллелизма)
3. [Chapter III](#chapter-iii) \
   3.1. [Part 1](#part-1-муравьиный-алгоритм)  \
   3.2. [Part 2](#part-2-решение-слау)  \
   3.3. [Part 3](#part-3-алгоритм-винограда)


## Chapter I

![Parallels](misc/images/Parallels.JPG)

Чак сел за стол с таким грохотом, что кофе на столешнице едва не выплеснулось из чашки.

`-` Ты не поверишь, что я только что узнал от чувака из ИБ, - начал он, выглядывая официанта. Это кафе было местом, которое они вдвоем облюбовали еще во времена студенчества. В меру заполненное людьми, с вкусным кофе и десертами, а самое главное - всегда тихое и спокойное. Как раз чтобы заниматься своими делами, работать, или учиться, что сейчас и делала Ева. Ее давно привлекала тема многопоточности и распараллеливания алгоритмов. А тут, наконец, нашлось время позаниматься и изучить ее как следует.

`-` Короче, наши "гении" наверху умудрились потерять какой-то опасный сверхразумный искусственный интеллект. - Чак перешел на шепот. - Уж не знаю, для какого пылесоса-убийцы они его там готовили, но все, похоже, в панике. Говорят Боб сам не свой.

`-` Звучит серьезно, - оторвалась от своих задачек Ева. - Я тоже слышала краем уха нечто подобное, но Боб не выглядел каким-то напуганным. Да и как можно потерять искусственный интеллект? Не выпал же он из кармана.

`-` Черт его знает. А вдруг сбежал сам? Так или иначе, но выглядит это все очень грязно. Ты видела наши финансовые отчеты? А я работаю с ними. И там все не очень радужно, чтобы еще вкладываться в каких-то инновационных роботов. Говорю тебе, они подпольно создают Терминатора.

`-` Да брось ты, - задумавшись произнесла Ева.

`-` Ну, вот увидишь, - отвлеченно ответил Чак. - Так, что это ты заказала? Ммм, пахнет вкусно...

## Introduction

В данном проекте вам предстоит ознакомиться с основными подходами к параллелизму, а также реализовать некоторые алгоритмы с его применением.


## Chapter II

### Многопоточность

**Синхронная программная модель** – это программная модель, в рамках которой каждому потоку назначается набор задач.
Все задачи в рамках потока выполняются последовательно друг за другом, когда завершено выполнение одной задачи, появляется возможность заняться другой.
В этой модели невозможно останавливать выполнение задачи, чтобы в промежутке выполнить другую задачу.

Частным случаем синхронной модели является *однопоточность*. Если имеется несколько задач, которые надлежит выполнить, и текущая система предоставляет один поток, который может работать со всеми задачами, то он берет поочередно одну за другой и процесс выглядит так:

![singlethreaded](misc/images/singlethreaded.png)

Здесь видно, что имеется поток и 4 задачи, которые необходимо выполнить.
Поток начинает выполнять поочередно одну за одной и выполняет их в итоге все.

В случаях, когда порядок, в котором задачи выполняются, не влияет на результат работы программы, может быть применена *многопоточность*.

Многопоточность является другим случаем синхронной модели – в этом сценарии, используются много потоков, которые могут брать задачи и приступать к работе с ними, т.е. у нас есть пулы потоков и множество задач. \
Итак, многопоточность может работать вот так:

![multithreaded](misc/images/multithreaded.png)

Здесь можно видеть, что у нас есть 4 потока и столько же задач для выполнения, и каждый поток начинает работать с ними.
Это идеальный сценарий, но в обычных условиях используется большее количество задач чем количество доступных потоков, таким образом освободившийся поток получает другое задание. \
Нежелательно каждый раз создавать новые потоки, потому что для этого требуется использование дополнительных системных ресурсов, таких как процессорное время, память. Поэтому изначальное количество потоков должно быть заранее заданным.

### Мьютексы

При написании многопоточных приложений почти всегда требуется работать с общими данными, одновременное изменение которых может привести к очень неприятным последствиям.
Для блокировки общих данных от одновременного доступа необходимо использовать *объекты синхронизации*.

**Мьютекс** (англ. mutex) представляет собой взаимно исключающий синхронизирующий объект.
Это означает, что он может быть получен потоком только по очереди.
Мьютекс предназначен для тех ситуаций, в которых общий ресурс может быть одновременно использован только в одном из потоков.
Допустим, что системный журнал совместно используется в нескольких процессах, но только в одном из них данные могут записываться в файл этого журнала в любой момент времени.
Для синхронизации процессов в данной ситуации идеально подходит мьютекс.

Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию.
Значение мьютекса устанавливается двумя процедурами: захвата и освобождения.
1. Если поток собирается войти в критическую область, он вызывает процедуру захвата.
2. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область.
3. Если мьютекс закрыт, то поток пытающийся войти в критическую секцию блокируется.
4. Если поток собирается выйти из критической области, он, соответственно, вызывает процедуру освобождения.

Принципы работы с мьютексами отличаются в Windows и Linux, но в общем случае можно выделить следующие шаги:
- Создание/Описание
- Открытие/Инициализация
- Попытка захвата и ожидание
- Освобождение

### Метод конвейерного параллелизма

Классическим способом применения многопоточности, в случае, когда необходимо решить одну и ту же задачу для некоторого количества *N* наборов исходных данных, является запуск всего алгоритма в одном потоке.
При таком подходе каждым потоком алгоритм выполняется для *N/(число_потоков)* наборов исходных данных.

**Конвейеризация** (или конвейерная обработка) в общем случае основана на разделении подлежащего исполнению алгоритма на более мелкие части, называемые ступенями, и выделении для каждой из них отдельного потока.
Так обработку любого набора данных можно разделить на несколько этапов, организовав передачу данных от одного этапа к следующему.
Производительность при этом возрастает благодаря тому, что на различных ступенях (в разных потоках) конвейера одновременно обрабатываются разные наборы данных.

Пример организации работы конвейера:

![pipeline](misc/images/conveyor.png)

В качестве конкретного примера можно привести алгоритм поиска наибольшего числа в строке.
На вход подается массив строк, для каждой из которых нужно выполнить поиск.
В первом потоке будет выполняться разбиение строки на слова, во втором приведение слов к числовому типу данных, в третьем поиск наибольшего среди чисел.
И тогда процесс работы будет выглядеть так:
1. В первом потоке обрабатывается 1-я строка из массива. Остальные строки ожидают своей очереди.
2. Массив слов, полученный после обработки 1-й строки поступает на обработку во 2-й поток. Так как первой поток освободился, в него на обработку поступает 2-я строка.
3. Далее переход между 2-м и 3-м потоками происходит так же, как и между 1-м и 2-м.
4. В случае, если 2-я строка обработалась в 1-м потоке быстрее, чем 1-я строка во 2-м потоке, 2-я строка поступает в очередь ожидающих освобождения 2-го потока. Тем временем, так как первой поток освободился, в него на обработку поступает 3-я строка.


## Chapter III

## Part 1. Муравьиный алгоритм

Необходимо реализовать муравьиный алгоритм для решения задачи коммивояжера из прошлого задания *A2_SimpleNavigator* с применением параллельных вычислений и без них:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- При написании кода необходимо придерживаться Google Style
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки программы (с целями all, clean, ant)
- У программы должен быть предусмотрен консольный интерфейс
- Пользователем задается матрица для задачи коммивояжера
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной матрицы
- Измерить время, которое потребуется для выполнения *N* раз муравьиного алгоритма с применением параллелизма для заданной пользователем матрицы
- Измерить время, которое потребуется для выполнения *N* раз обычного муравьиного алгоритма для заданной пользователем матрицы
- На экран вывести полученное в обоих случаях время
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 2. Решение СЛАУ

Необходимо реализовать обычный и параллельный алгоритмы решения СЛАУ методом Гаусса:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- При написании кода необходимо придерживаться Google Style
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Добавить в существующий Makefile цель "gauss" для сборки программы
- У программы должен быть предусмотрен консольный интерфейс
- Пользователем задается матрица, описывающая СЛАУ
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз параллельного алгоритма решения заданной пользователем СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз обычного алгоритма решения заданной пользователем СЛАУ
- Вывести на экран полученное в обоих случаях время
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 3. Алгоритм Винограда

Необходимо реализовать алгоритм Винограда умножения матриц без применения параллелизма, а также с использованием конвейерного и классического способов параллелизма:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- При написании кода необходимо придерживаться Google Style
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Добавить в существующий Makefile цель "winograd" для сборки программы
- Должно быть выделено 4 стадии работы конвейера
- У программы должен быть предусмотрен консольный интерфейс
- Должно быть предусмотрено 2 способа ввода:
    - Пользователем задаются обе матриц для умножения
    - Пользователем задаются размерности матриц, которые затем заполняются в программе случайным образом
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов, а также сгенерированные матрицы
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц без применения параллелизма
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением классического параллелизма при количестве потоков, равном 2, 4, 8, ..., 4 * (число логических процессоров компьютера)
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением конвейерного параллелизма
- Вывести на экран полученное в каждом случае время
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

